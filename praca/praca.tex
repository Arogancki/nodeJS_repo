\documentclass[12pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{txfonts}
\usepackage{listings}
\usepackage{float}
\usepackage{color}
\usepackage{xcolor}
\usepackage{enumitem}
\graphicspath{{images/}}
\renewcommand{\chaptername}{Rozdzia³}
\renewcommand{\contentsname}{Spis treœci}
\renewcommand{\figurename}{Rysunek}
\renewcommand{\listfigurename}{Spis rysunków}
\renewcommand{\bibname}{Bibliografia}
\setlength{\textwidth}{14cm}
\setlength{\textheight}{20cm}
\newtheorem{definition}{Definicja}
\newtheorem{example}{Przyk³ad}[chapter] 
\newtheorem{corollary}{Wniosek}[chapter]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{blue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type}% list your attributes here
}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  showstringspaces=false,
  commentstyle=\color{gray}\upshape
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\begin{document}
\begin{titlepage}
	\centering
	{\scshape\LARGE Celem pracy jest przedstawienie technologii Node.js na przyk³adzie zaprojektowanej aplikacji przeznaczonej do zarz¹dzania codziennymi zadaniami.  \par}
\end{titlepage}
\tableofcontents

\chapter{Przedstawienie ogólne, ideologii oraz przeznaczenia technologii Node.js}

\section{Wstêp}
Node.js czyli cross-platformowy, dzia³aj¹cy niezale¿nie od œrodowiska jêzyk programowania napisany w jêzykach c/c++ oraz javascript wydany 27 marca 2009 roku, zaprojektowany przez Ryana Dahla. 
Pozwala na tworzenie serwerów i narzêdzi sieciowych dzia³aj¹cych po stronie serwera. 
Przed powstaniem jêzyka kod javascriptowy by³ wykonywany g³ównie przez przegl¹darkê internetow¹ po stronie klienta, co pozwala³o na bezproblemow¹ manipulacje kodem Ÿród³owym strony przez u¿ytkownika, daj¹c mo¿liwoœæ wykonywania z³oœliwych skryptów, naruszenie bezpieczeñstwa baz danych lub uzyskania dostêpu do chronionych zasobów servera. 
Œrodowisko Node.js mo¿e dzia³aæ niezale¿nie od œrodowiska uruchomieniowego. 
Jest ono zgodne z wieloma systemami operacyjnymi jak  Linux, macOS, Microsoft Windows, NonStop, czy serwerami Unix. 
Jêzyk ten cieszy siê du¿¹ popularnoœci¹ oraz pozytywnym odbiorem wœród u¿ytkowników, dziêki czemu mimo wzglêdnie krótkiego okresu ¿ycia œrodowiska zaowocowa³o ogromn¹ iloœci¹ projektów open-source, tysi¹cami cz³onków nale¿¹cych do spo³ecznoœci oko³ojêzykowej oraz powstaniem wydarzeñ poruszaj¹cych tematy oko³oœrodowiskowe, takimi jak NodeConf, Node Interactive lub Node Summit. 
Obecnie wiele najwiêkszych firm korzysta z serwerów napisanych w jêzyku Node.js. 
Ich przyk³adami s¹ miêdzy innymi Groupon, IBM, Linkedln, Microsoft, Netflix, PayPal, Yahoo. 
Najpopularniejszymi API wspieraj¹cymi edycjê oraz debugowanie kodu Node.js s¹ Atom, Brackets, JetBrains, Microsoft Visual Studio, NetBeans czy Nodeclipse.

\section{Przeznaczenie}
Node.js zalecany jest do tworzenia aplikacji: 
\begin{itemize}
\item z du¿¹ liczb¹ operacji wejœcia/wyjœcia,
\item strumieniowania danych np. video, 
\item Single Page Applications (SPA),
\item udostêpniaj¹cych API w formacie JSON,
\item z intensywn¹ wymian¹ danych w czasie rzeczywistym na wielu urz¹dzeniach, np. portale spo³ecznoœciowe.
\end{itemize} 
Poniewa¿ jest on szybki i lekki, mo¿e byæ stosowany do pisania miêdzy innymi bramki API. 
API to skrót od Application Programming Interface; opisuje, jak poszczególne elementy lub warstwy oprogramowania powinny siê komunikowaæ. 
W praktyce to najczêœciej biblioteka oferuj¹ca metody, które umo¿liwiaj¹ realizacjê okreœlonych zadañ. 
Node.js pozwala na zoptymalizowanie pracy oraz uzyskanie skalowalnoœci dziêki asynchronicznemu przetwarzaniu danych dostarczanych do aplikacji, w zwi¹zku z czym idealnie nadaje siê do obs³ugi komunikacji wymagaj¹cej pracy w czasie rzeczywistym. 
Funkcje napisane w Node.js wykonuj¹ siê równolegle, korzystaj¹c z tak zwanych wywo³añ zwrotnych (ang. callback), przeciwnie do jêzyków takich jak np. php, gdzie program jest wykonywany synchronicznie - linia po linii. 
Dziêki temu nie powstaje problem blokowania okreœlonych funkcjonalnoœci programu w czasie pracy innych niezale¿nych jego czêœci. 
Przy pomocy wywo³añ zwrotnych mo¿emy zapewniæ zasygnalizowanie uzyskanych wyników lub zwrócenie, b¹dŸ obs³ugê b³êdu powsta³ego w czasie dzia³ania bloku kodu.

\section{Modu³owoœæ}
Praca z Node.js opiera siê g³ównie o korzystanie ze zbioru zdefiniowanych w ramach modu³ów funkcji wspieraj¹cych okreœlone funkcjonalnoœci. 
Zapewniaj¹ one pracê miêdzy innymi z plikami systemowymi, z urz¹dzeniami wejœcia/wyjœcia, protoko³ami internetowymi (dns, http, tcp, tls/ssl, udp), plikami binarnymi, Ÿród³ami danych oraz funkcjami kryptograficznymi. 
Zmniejszaj¹ one z³o¿onoœæ, a co za tym idzie nak³ad pracy przy tworzeniu w³asnej funkcjonalnoœci. 
Dziêki wsparciu package managera (od roku 2010) nazywanego npm programiœci mog¹ bez przeszkód udostêpniaæ napisane przez siebie modu³y i biblioteki lub w prosty sposób zaimportowywaæ ogólnie dostêpne modu³y i u¿ywaæ ich w swoich projektach. 
Najpopularniejszymi modu³ami wykorzystywanymi w celu poprawy jakoœci oraz zmniejszenia nak³adów pracy przy wytwarzaniu oprogramowania s¹ Express.js, Socket.IO, Hapi.js, Sails.js czy Meteor. 
Npm jest automatycznie w³¹czony w œrodowisko Node.js. 
Jest obs³ugiwany za pomoc¹ linii komend systemu operacyjnego. 
Modu³y s¹ zapisane w formacie CommonJS oraz zawieraj¹ pliki informacyjne w formacie Json. 
Iloœæ ogólnodostêpnych modu³ów przekracza obecnie 477000. 
Jest to spowodowane mo¿liwoœci¹ przez ka¿dego u¿ytkownika Node.js, bez potrzeby wczeœniejszej rejestracji czy przejœcia jakiejkolwiek procedury wstêpnej, udostepnienia napisanego przez siebie kodu. 
W zwi¹zku z tym, wiele dostêpnych modu³ów jest niskiej jakoœci, mo¿e zawieraæ elementy z³oœliwego oprogramowania lub nie byæ bezpiecznym dla naszego systemu operacyjnego. 
Nale¿y bezwzglêdnie braæ te czynniki pod uwagê w przypadku korzystania z nieznanych modu³ów i najlepiej najbardziej znacz¹co ograniczyæ korzystanie z nich bez wczeœniejszej weryfikacji kodu Ÿród³owego. 
Zabezpieczeniami w celu ochrony u¿ytkowników, które dostarcza npm, jest usuwanie pakietów, które zosta³y zg³oszone przez u¿ytkowników jako naruszaj¹ce ogólne zasady bezpieczeñstwa oraz mo¿liwoœæ wgl¹du w raporty statystyczne odnoœnie iloœci pobrañ lub iloœci zale¿nych od modu³u innych pakietów. 
Kolejnym zagro¿eniem, jakie niesie korzystanie z pakietów udostêpnionych przez innych u¿ytkowników, jest mo¿liwoœæ usuniêcia udostêpnionego pakietu z repozytorium npm, w konsekwencji uniemo¿liwiaj¹c naszej aplikacji dalsze korzystanie z pakietu. 
Sytuacja taka mia³a miejsce, kiedy skrypt zwany ,,left-side'', z którego korzysta³o ponad 2486696 deweloperów, zosta³ usuniêty z repozytorium powoduj¹c tak zwany efekt domina, bêd¹cy przyczyn¹ b³êdów w kolejnych aplikacjach deweloperów. 
Npm korzysta, tak jak i inne globalnie dzia³aj¹ce narzedzia JavaScriptowe, z plików zale¿noœci w formacie json. 
Opisuj¹ one wersjê wykorzystywanych modu³ów i pozwalaj¹ za pomoc¹ jednoliniowej komendy na szybk¹ i ³atw¹ instalacjê wszystkich u¿ywanych pakietów w lokalnym œrodowisku. 

\chapter{Omówienie architektury Node.js}

\section{Paradygmat}
Architektura Node.js pozwala na tworzenie oprogramowania sterowanego zdarzeniami (event-driven programming). 
Jest to paradygmat programowania, w którym kolejnoœæ wykonywania kodu zale¿y od zdarzeñ maj¹cych miejsce w czasie ¿ycia aplikacji (run time), na przyk³ad interakcji u¿ytkownika, czy otrzymania okreœlonych sygna³ów. 
W przypadku jêzyka Node.js, kiedy aplikacjia pe³ni rolê serwera, paradygmat ten najczêœciej dotyczy przetwarzania zapytañ otrzymywanych ze strony klienta oraz uruchomionych przez nie zdarzeñ tzn. funkcji. 
W aplikacji sterowanej zdarzeniami nale¿y wyró¿niæ pêtlê g³ówn¹, która jest odpowiedzialna za obs³ugê zachodz¹cych w czasie rzeczywistym zdarzeñ, czyli wywo³ywanie triggerów jako wywo³añ zwrotnych. 
S¹ to wyodrêbnione czêœci kodu, które po wykonaniu swojego zadania zwracaj¹ okreœlon¹ wartoœæ lub obiekt. 
W Node.js jest to na przyk³ad funkcja nas³uchuj¹ca okreœlonego adresu, pod który klienci kieruj¹ okreœlone zapytania. 
Pozwala to na wykonywanie wielu zadañ jednoczeœnie i niezale¿nie. 
Zapewnia przyspieszenie wykonywania skomplikowanych funkcji programu. 
Daje mo¿liwoœæ przyk³adowo jednoczesnego zapisywania danych do bazy, przetwarzania innej czêœci zapytania i przygotowywanie odpowiedzi w jednym okresie czasu. 
Node.js zapewnia w ten sposób dzia³anie asynchroniczne, bez bezpoœredniego u¿ycia technologii wielow¹tkowej. 
Wychodzi naprzeciw problemowi tworzenia oraz kontrolowania aplikacji wspó³bie¿nych spe³niaj¹cych zadanie serwera, które s¹ trudne do zaimplementowania w wielu jêzykach programowania oraz czêsto prowadzi³y do niesatysfakcjonuj¹cej wydajnoœci. 
Jêzyk zosta³ stworzony na silniku V8 javaScript napisanym w jêzyku C++, wyprodukowanym przez Google, wykorzystywanym w przegl¹darkach Google Chrome, który porzuca tradycyjn¹ ideê interpretowania kodu javaScriptowego linia po linii, zapewniaj¹c w zamian kompilacje do odpowiednio zoptymalizowanego kodu maszynowego przed jego wykonaniem, a co za tym idzie, wiêksz¹ wydajnoœci¹ podczas dzia³ania programu. 
Zapewnia on równie¿ odpowiednie zarz¹dzanie pamiêci¹ dla obiektów, œci¹gaj¹c z programistów odpowiedzialnoœæ alokowania oraz zwalniania zajêtych zasobów.

\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{eventLoop.png} 
\caption{Pêtla zdarzeñ w œrodowisku Node.js - Ÿród³o: http://galaxy.agh.edu.pl}
\end{figure}

\section{Asynchronicznoœæ}
Node.js pracuje wykorzystuj¹c tylko jeden w¹tek, u¿ywaj¹c technologii asynchronicznego wejœcia/wyjœcia. 
Zapewnia to synchronizacje wykonywania wielu operacji bez koniecznoœci czekania na zakoñczenie operacji i zwolnienie dostêpu do zasobu poprzez zarz¹dzanie ¿¹daniami wejœcia/wyjœcia w oderwaniu od w¹tków wykonywania. 
Standardowe operacje synchroniczne powoduj¹ zablokowanie dalszego wykonywania w¹tku do czasu zakoñczenia przetwarzania. 
W rezultacie okreœlony w¹tek mo¿e zainicjowaæ tylko jedno zadanie wejœcia/wyjœcia w jednym momencie. 
Wywo³anie asynchroniczej funkcji nie czeka na wyniki, dziêki czemu nie blokujemy w¹tku wykonawczego. 
Po zakoñczonym wywo³aniu uruchomiona zostaje funkcja zwrotna lub og³oszone zostaje zdarzenie w poszczególnych czêœciach wykonawczych. 
Pomimo, ¿e Node.js dzia³a na jednym w¹tku z pêtl¹ zdarzeñ, dziêki asynchronicznoœci potrafi on obs³u¿yæ wiêcej zapytañ ni¿ np. serwer HTTP Apache. 
Uzyskanie wielow¹tkowoœci pomimo korzystania tylko z jednego w¹tku jest zapewnione dziêki u¿yciu wzorca projektowego obserwator, w którym jeden obiekt nazywany przedmiotem obserwowanym okreœla zale¿noœci wzglêdem obserwuj¹cych go innych obiektów, poprzez wywo³ywanie ich metod dla okreœlonych w³asnych stanów. 
W celu obs³ugi wszystkich asynchronicznych funkcji oraz w¹tku g³ównego Node.js korzysta z biblioteki multiplatformowej jêzyka c - libuv. 
Biblioteka ta zosta³a stworzona specjalnie na potrzebny Node.js, ale jest równie¿ wykorzystywana w wielu innych technologiach, np. racer: (obs³uga serwerów w jêzyku ruby), czy Trevi: (silnik do obs³ugi aplikacji internetowych w jêzyku swift). 
Wykorzystuje ona okreœlony zbiór w¹tków do równoleg³ej obs³ugi wielu operacji wejœcia/wyjœcia bez wzajemnego ich blokowania. 
Wad¹ pracy Node.js przy wykorzystaniu tylko jednego w¹tku jest brak skalowalnoœci pod wzglêdem mo¿liwoœci zwiêkszenia iloœci rdzeni procesorów, na których wykonuje siê program, bez u¿ycia dodatkowych modu³ów, takich jak Cluster (zapewnia mo¿liwoœæ ³atwego tworzenia pochodnych procesów, które wspó³dziel¹ porty serwera), StrongLoop PM (zapewnia zarz¹dzanie procesem produkcyjnym aplikacji Node.js ze wsparciem odpowiedniego zarz¹dzania zasobami, wdro¿eniami wielohostowymi oraz interfejsem graficznym), czy PM2 (zarz¹dzanie procesem produkcyjnym, ze wsparciem odpowiedniego zarz¹dzania zasobów z mo¿liwoœci¹ nieprzerwanego dzia³ania aplikacji przy u¿yciu przenoszenia jej miêdzy domenami, bez potrzeby zatrzymywania pracy). 
Kolejn¹ mo¿liwoœci¹ na unikniêcie tego ograniczenia jest zmiana iloœci w¹tków nale¿¹cych do zbioru wykorzystywanego przez bibliotekê libuv. 
W¹tki te dzia³aj¹ na wielu rdzeniach systemu, na którym dzia³a serwer. 
Dzia³anie Node.js jednoczeœnie na wielu procesach jest zapewnione w³aœnie dziêki zbiorowi w¹tków dostarczanych przez bibliotekê libuv.
W¹tek g³ówny przydziela zadania dla w¹tków kolejno ze wspó³dzielonej kolejki funkcji, które w¹tki pochodne maj¹ za zadanie wykonaæ. 
Kiedy w¹tek pochodny zakoñczy wykonywanie przydzielonego mu zadania, informuje o tym w¹tek g³ówny poprzez wywo³anie okreœlonego wywo³ania zwrotnego. 
Z przyczyny odpowiedzialnoœci przez watek g³ówny do odebrania wszystkich wywo³añ zwrotnych, funkcja wykonywana przez jeden w¹tek pochodny mo¿e wstrzymaæ dzia³anie ca³ej asynchronicznej operacji, a co za tym idzie, zmniejszyæ jej ca³kowit¹ wydajnoœæ. 
Biblioteka libuv zajmujê siê odpowiednim podzia³em zadañ oraz przydzieleniem zasobów tak, aby w jak najlepszy sposób wywa¿yæ nak³ad pracy miêdzy wieloma w¹tkami. 
\newpage
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{thread.png} 
\caption{Model programowania wspó³bie¿nego wykorzystywany przez Node.js - Ÿród³o: www.tutorialspoint.com/parallel\_algorithm/}
\end{figure}

\section{Architektura komunikacji}
W tradycyjnym podejœciu odpowiedzialne za obs³ugê przychodz¹cych po³¹czeñ s¹ okreœlone w¹tki lub procesy sytemu operacyjnego, które w porównaniu z technologi¹ Node.js wymagaj¹ wzglêdnie wiêcej zaalokowanych zasobów. 
W celu obs³ugi zapytania przychodz¹cego do aplikacji Node.js, program rejestruje siê w systemie operacyjnym, aby od ka¿dego przychodz¹cego po³¹czenia otrzymaæ odpowiednie wywo³anie zwrotne, przez co nie potrzebuje procesów czy w¹tków, aby uzyskaæ mo¿liwoœæ obs³ugi klientów, a tylko w³asnej pêtli g³ównej, do której wykonywania powraca po przetworzeniu ka¿dego wywo³ania wstecznego. 
W czasie pracy ka¿de przychodz¹ce po³¹czenie otrzymuje odpowiedni¹ iloœæ zasobów na stercie programu, wiêc nie ma równie¿ potrzeby alokowania zasobów dla ka¿dego z w¹tków czy procesów osobno. 
Najbardziej popularna metoda na zarz¹dzanie komunikacj¹ miêdzy instancjami korzystaj¹cymi z serwera u¿ywaj¹cego technologii Node.js jest wykorzystanie frameworku Restful Api popularnie zwanego Rest. 
Jest to wzorzec architektury oprogramowania, który opisuje sposób operowania zapytaniami pomiêdzy Api, w prosty sposób poprzez obs³ugê zadañ oraz odpowiedzi. 
Zosta³ on nastêpnikiem protoko³u sieciowego SOAP (Simple object Access protocol), staj¹c siê wiod¹cym standardem. 
Pozwala on na eliminacjê zbêdnej pracy i czasu wymaganego na integracjê. 
Daje mo¿liwoœæ na stworzenie komunikacji bez potrzeby wiedzy na temat instancji korzystaj¹cych z przesy³anych zasobów - mo¿e integrowaæ œrodowiska napisane w ró¿nych jêzykach, dzia³aj¹ce na ró¿nych platformach. 
Wykorzystuje proste zapytania przy u¿yciu protoko³u http, oraz jego popularnie stosowanych metod takich jak post, get, put, delete oraz bardziej z³o¿onych i u¿ywanych rzadziej jak options, head, trace oraz connect. 
Opis typu zasobów, jakie wymieniamy, jest okreœlony w nag³ówku informacji przez kod statusu http. 
Poni¿sza tabelka prezentuje poszczególne typy statusów:
\newpage
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{statuses.png} 
\caption{Kody statusu protoko³u http - Ÿród³o: http://mokandra.blogspot.fi/2015/10/http-status-code-definitions.html}
\end{figure}

W celu wymiany zasobów framework wykorzystuje najpopularniejsze sposoby opisu struktury s³u¿¹ce do opisu obiektów, takie jak najczêœciej spotykany, najprostszy w u¿yciu format json (JavaScript Object Notation) oraz mniej popularny w technologii Rest format xml (eXtensible Markup Language). 
Ró¿nica pomiêdzy dwiema formami jest taka, ¿e xml jest jêzykiem niezdefiniowanych znaczników, a json tylko sposobem na prezentacjê w³aœciwoœci obiektu. 
Porównanie obydwu struktur:
Struktura w formacie json opisuj¹ca listê pracowników:
\begin{lstlisting}[language=json,firstnumber=1]
{"employees":[
	{ "firstName":"James", "lastName":"Bond" },
	{ "firstName":"David", "lastName":"Klint" },
	{ "firstName":"Peter", "lastName":"Blom" }
]}
\end{lstlisting}

Ta sama struktura opisana w formacie xml:
<employees>
\begin{lstlisting}[language=XML,firstnumber=1]
	<employee>
		<firstName>James</firstName> <lastName>Bond</lastName>
	</employee>
	<employee>
		<firstName>David</firstName> <lastName>Klint</lastName>
	</employee>
	<employee>
		<firstName>Peter</firstName> <lastName>Blom</lastName>
	</employee>
</employees>
\end{lstlisting}


\chapter{Za³o¿enia i specyfikacja aplikacji}

\section{Specyfikacja problemu}
Potrzebny jest nowoczesny system do zarz¹dzania tablicami zadañ, który bêdzie posiada³ autoryzowany dostêp dla u¿ytkowników systemu. 
Zosta³ zauwa¿ony problem braku prostej w obs³udze, intuicyjnej aplikacji pozwalaj¹cej we wspó³pracy z innymi u¿ytkownikami na zarz¹dzanie zarówno podzia³em jak i procesem realizacji wyszczególnionych zadañ.
W celu reakcji na zapotrzebowanie zostanie zaprojektowany system informatyczny pracuj¹cy w technologii Node.js, ze wzglêdu na mo¿liw¹ do osi¹gniecia niezawodnoœæ oraz dostêpnoœæ nawet przy jednoczesnej obs³udze wielu korzystaj¹cych z aplikacji klientów.
Nie powinien on wymagaæ ¿adnych procesów wdro¿eniowych w celu zrozumienia obs³ugi narzêdzia, poniewa¿ celem projektu jest stworzenie narzêdzia, które wspiera, a nie dodatkowo komplikuje okreœlone zadania.
System powinien w przejrzysty sposób prezentowaæ proces realizacji poszczególnych zadañ zorganizowanych w tablicach.
W³aœciciel okreœlonej tablicy powinien mieæ mo¿liwoœæ zarz¹dzania dostêpem do tablicy poprzez udostêpnianie lub ograniczanie jej treœci pozosta³ym u¿ytkownikom.
Aplikacja zapewni subskrybentom nieprzerwan¹ mo¿liwoœæ nadzoru, wgl¹du oraz okreœlania aktualnych statusów dowolnych procesów.

\section{Wymagania funkcjonalne}
Analiza wymagañ funkcjonalnych umo¿liwia zidentyfikowanie i opisanie po¿¹danego zachowania systemu. 
Umo¿liwiaj¹ okreœlenie us³ug oferowanych przez system, reakcji na dane wejœciowe oraz zachowania w okreœlonych sytuacjach.
\begin{itemize}
\item Wymiana komunikatów w modelu klient-serwer.
\item Mo¿liwoœæ utworzenia do 1000000 kont u¿ytkowników.
\item Mo¿liwoœæ zmiany danych u¿ytkownika.
\item Weryfikacja adresu email przed aktywacj¹.
\item Mo¿liwoœæ resetowania has³a za pomoc¹ adresu email.
\item Utrzymanie do 100 tablic jednoczeœnie dla u¿ytkownika.
\item Mo¿liwoœæ usuwania tablic.
\item Obs³uga do 1000 równoleg³ych cz³onków jednej tablicy.
\item Mo¿liwoœæ zarz¹dzania cz³onkami tablicy.
\item Obs³uga do 10000 równoleg³ych zadañ dla tablicy.
\item Mo¿liwoœæ usuwania zakoñczonych zadañ.
\item Utrzymanie do 1000 statusów do jednego zadania.
\item Zapamiêtywanie terminu zmiany statusu zadañ.
\item Walidacja poprawnoœci wprowadzanych przez u¿ytkownika danych zarówno po stronie klienta jak i serwera.
\item W razie wyst¹pienia nieprawid³owych danych system powiadamia o b³êdach.
\item Zapewnienie okna pomocy opisuj¹cego korzystanie z aplikacji.
\item Mo¿liwoœæ otrzymywania powiadomieñ o aktualnym statusie tablic oraz poszczególnych zadañ.
\item System wspó³pracuje z baz¹ danych.
\end{itemize}

\section{Wymagania pozafunkcjonalne}
Wymagania niefunkcjonalne opisuj¹ kryteria umo¿liwiaj¹ce dokonanie oceny dzia³ania systemu i elementów maj¹cych wp³yw na satysfakcjê u¿ytkownika.
Zdefiniowane zosta³y nastêpuj¹ce wymagania niefunkcjonalne:

\begin{itemize}
\item Dostêp do okreœlonych zasobów musi byæ chroniony poprzez login i has³o u¿ytkownika.
\item Budowa interfejsu u¿ytkownika musi byæ mo¿liwie intuicyjna i prosta w obs³udzê.
\item Proste analizowanie i diagnozowanie b³êdów oraz sytuacji problemowych.
\item Budowa zapewnia ³atwe wprowadzanie koniecznych zmian.
\item Jest w stanie obs³u¿yæ jednoczeœnie do 100.000 u¿ytkowników.
\item Czas uruchomienia jest nied³u¿y ni¿ 10 sekund.
\item Umo¿liwia efektywne testowanie wprowadzonych zmian.
\item Mo¿liwoœæ obs³ugi poprzez ró¿ne przegl¹darki internetowe i œrodowiska.
\item Zrozumia³y dla wszystkich. Czas przyswojenia nie przekracza 15 minut.
\item Ma mo¿liwoœæ wspó³istnienia z innymi modu³ami.
\item Spe³nia wszystkie normy prawne w naszym kraju.
\end{itemize}

\chapter{Opracowanie aplikacji}

\section{Mean Stack}

\subsection{Wstêp}
Do opracowania rozwi¹zania zdecydowa³em siê skorzystaæ z Mean Stack. 
Skrót odnosi siê do frameworków oraz technolgji Mongodb, Express, AngularJS oraz Node.js. 
Wspó³pracuj¹c razem zapewniaj¹ bardzo szybkie efektywne tworzenie skalowalnych aplikacji wieloplatformowych. 
Do u¿ycia wszystkich wymagany jest tylko jeden jêzyk programowania - javaScript, zarówno do obs³ugi warstwy frontendowej aplikacji jak i backendowej. 
Wszystkie technologie s¹ dostêpne w pe³ni bezp³atnie. 

Jako i¿ Technologia Node.js zosta³a ju¿ opisana, przejdê do opisu pozosta³ych technologii.

\subsection{MongoDB}
Napisany w jêzyku c++ system zarz¹dzania baz¹ danych zorientowanym na dokumenty. 
Operuje na nierelacyjnych bazach danych. 
U¿ywa struktur json jako schematów budowy bazy danych.
Udostêpnia ca³kowit¹ dowolnoœæ w budowie struktury wymaganej bazy danych. 
Wykorzystuje proste, ale zapewniaj¹ce szerokie mo¿liwoœci zapytania bazodanowe.

\subsection{ExpressJS }
Framework s³u¿¹cy do szybkiego wymagaj¹cego jak najmniejszych nak³adów pracy wytwarzania zarówno backendu aplikacji internetowych, jak i aplikacji mobilnych.
Dostarcza zbiór okreœlonych klas i metod. Jest to najpopularniejszy framework do tworzenia serwerów w technologii Node.js.

\subsection{AngularJS}
Wykorzystuj¹cy wzorzec projektowy MVC (Model View Controler) polegaj¹cy na oddzieleniu od siebie poszczególnych warstw aplikacji - logiki, widoku oraz modelu komunikacji, framework wykorzystuj¹cy dodatkowe tagi w jêzyku html w celu prostego w obs³udze i niewymagaj¹cego dodatkowej logiki napisanej w jêzyku javaScript tworzenia dynamicznych stron internetowych.

\section{Komunikacja}

\subsection{Rozwi¹zanie problemu komunikacji}
Do komunikacji miêdzy warstw¹ frontendow¹ i backendowow¹ po stronie klienta wykorzysta³em wysokopoziomow¹ bibliotekê Ajax oraz technologiê Restful api. 
Ajax polega na zarz¹dzaniu asynchroniczn¹ komunikacj¹. 
Dziêki temu aplikacja mo¿e wykonywaæ inne funkcje, mimo oczekiwania na odpowiedŸ ze strony serwera, za spraw¹ odseparowania warstwy wymiany danych od pozosta³ych warstw aplikacji.
Do opisu wymienianych struktur u¿y³em standardu json, poniewa¿ wymaga on mniejszych nak³adów pracy od standardu xml. 
Powy¿sze frameworki wspó³pracuj¹ ze sob¹ w bardzo intuicyjny i przejrzysty sposób. 
Angular prezentuje dynamiczn¹ aplikacje internetowa u¿ytkownikowi, odpowiada za przyjmowanie danych i z pomoc¹ ajaxa wysy³a oraz odbiera dane wysy³ane do serwera. 
Serwer Node.js z u¿yciem technologii express, wykorzystuj¹c metodê routingu, dopasowuje zapytanie do odpowiednich funkcji serwisu, przetwarza otrzymane dane, przy wspó³pracy z baz¹ danych zarz¹dzana przez Mongodb przechowuje informacje u¿ytkowników serwisu oraz w odpowiedzi zwraca odpowiednie dane z powrotem do warstwy frontendowej prezentuj¹cej dane u¿ytkownikowi. 
\newpage
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{Meanex.png}
\caption{Przep³yw komunikacji w MEAN Stack Ÿród³o: https://www.dealfuel.com/seller/mean-stack-tutorial/}
\end{figure}

\subsection{Schematy wymiany zasobów}
Uniwersalny dla aplikacji schemat procesu pobrania statycznych zasobów z serwera wykorzystuje metodê get. Do zasobów tych nale¿y miedzy innymi plik html zawieraj¹cy warstwê prezentacji aplikacji, plik css zawieraj¹cy styl warstwy prezentacji, czy plik zawieraj¹cy funkcje wykorzystywane przez aplikacje w jêzyku javaScript. Proces prezentuje siê nastêpuj¹co:
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{K-S.png} 
\caption{Pobranie statycznych zasobów, Ÿród³o: Opracowanie w³asne}
\end{figure}
\begin{enumerate}
\item Klient przy u¿yciu przegl¹darki wysy³a pod okreœlony adres url serwera zapytanie zawieraj¹ce po¿¹dany zasób.
\item Serwer otrzymuje zapytanie i dopasowuje okreœlon¹ funkcjê po adresie url serwera.
\item Funkcja wybiera dopasowane do zapytania zasoby i wysy³a odpowiedŸ do aplikacji.
\item Aplikacja odbiera i zaczyna korzystaæ z zasobów.
\end{enumerate}

 Uniwersalny dla aplikacji schemat procesu wymiany danych okreœlonych dla specyficznego u¿ytkownika wykorzystuje metodê post. Przyk³adowe dane wymieniane przez aplikacje to login, has³o, informacje odnoœnie ¿¹dañ u¿ytkownika, komentarze do zadañ u¿ytkownika. Przep³yw danych wygl¹da nastêpuj¹co:
 \begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{U-P-S-B.png} 
\caption{Wymiana zasobów w formacie Json Ÿródlo: Opracowanie w³asne}
\end{figure}
\begin{enumerate}
\item Dane zostaj¹ pobrane od u¿ytkownika w okreœlonym formularzu w warstwie frontendowej.
\item Dane zostaj¹ zwalidowane pod k¹tem poprawnoœci po stronie u¿ytkownika.
\item Jesli dane s¹ poprawne, zostaja zorganizowane w obiekcie json i wys³ane do serwera, w przeciwnym wypadku zostaje zwrócony b³¹d.
\item Serwer odbiera zapytanie i przekazuje je do odpowiedniej funkcji.
\item Dane zostaj¹ zwalidowane pod k¹tem poprawnoœci po stronie serwera.
\item Jeœli dane s¹ poprawne, serwer realizuje okreœlon¹ funkcjê przy pomocy zapytañ bazodanowych, w przeciwnym wypadku zostaje przygotowany komunikat o b³êdzie.
\item OdpowiedŸ na zapytanie bazodanowe zostaje odebrane i zostaj¹ przygotowane dane do wys³ania.
\item Przygotowane dane zostaje wys³ane w okreœlonej odpowiedzi.
\item Warstwa frontendowa otrzymuje odpowiedŸ i zostaje odœwie¿ona warstwa prezentacji aplikacji.
\end{enumerate}
 

\subsection{Kod po stronie klienta wysy³aj¹cy ¿¹danie}
Przyk³adowy kod wykonywany po stronie klienta, wysy³aj¹cy ¿¹danie do serwera, ¿¹daj¹ce okreœlonego zasobu przy u¿yciu frameworku Angularjs:
Plik w jêzyku javaScript zawieraj¹cy definicje modelu i kontrolera:
\medskip
\begin{lstlisting}
var main = angular.module("main", []); 									// create angular module

main.controller('SignInController', function($scope) { 					// create controller for module
	$scope.login=""; 													// initialize login as field in model
	$scope.password=""; 												// initialize password as field in model
	$scope.SignIn=function(){ 											// callback function as field in model
		if ($scope.login && $scope.password) {							// if both field are filled
			var xhr = new XMLHttpRequest();									//create request object
			xhr.open("POST", http://site.com/authorization, true);		// set method type, domain address and is it asynchronous
			xhr.setRequestHeader("Content-type","application/json");	// set header with information of content type
			req.send(JSON.stringify({	login: $scope.login,			
										password: $scope.password})); 	// Send json object with login and password
			req.onreadystatechange = function() { 						// create callback, called on every state change
				if (req.readyState === 4) { 							// readyState 4 is 4 when respond is got
					if (req.status === 200) { 							// http status code 200 - ok
						var resObj = JSON.parse(this.responseText);		// parse response text to json object
						$scope.login=resObj.login;						// set password from response
						$scope.password=$resObj.password;				// set password from response
						alert("Login and password are valid");			// alert user
					}
					else if (req.status === 401){						// http status code 200 -  Unauthorized
						$scope.invalid=req.responseText;  				// set response message containing error in view model
						$scope.$apply(); 								// apply changes on view model
					}
					else{ 												// all other http statusses
						alert(req.status+":"req.responseText); // alert user
					}
				}
			}
		}
	}
}
\end{lstlisting}
\newpage
Plik w jêzyku html zawieraj¹cy definicje widoku:
\begin{lstlisting}[language=HTML]
<!DOCTYPE html> 
<!-- Apply view to model -->
<body ng-app = "main">
	<!-- Create form for request -->
	<form class="main" name="form""> 
		<table>
			<tr>
				<td style="width:50%;">
					Login
				</td>
				<td style="width:50%">
						<!-- Get user login -->
						<input type = "text" ng-model = "login" name="login"
							<!-- Set field validation -->
							required ng-pattern='/^[a-zA-Z0-9._-]+$/'  ng-maxlength="20" ng-minlength="3">
				</td>
			</tr>
			<tr>
				<td style="width:50%;">
					Password
				</td>
				<td style="width:50%">
						<!-- Get user password -->
						<input type = "text" ng-model = "password" name="password"
						<!-- Set field validation -->
							required ng-pattern='/^[a-zA-Z0-9._-]+$/'  ng-maxlength="20" ng-minlength="3">
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<!-- show error message field from server only if invalid field exist -->
					<p ng-show="invalid">{{invalid}}</p>
					<!-- show static error message only if one of user field are invalid -->
					<p ng-show="form.login.$invalid || form.password.$invalid">Invalid login or password</p>
				</td>	
			</tr>
		</table>
	</form>
</body>
\end{lstlisting}

\subsection{Kod po stronie serwera obs³uguj¹cy odebranie ¿¹dania}
Przyk³adowy kod wykonywany po stronie serwera obs³uguj¹cy odebrane ¿¹danie od klienta przy u¿yciu technologii Node.js oraz frameworków express i mongodb:
\medskip
\begin{lstlisting}
var express = require('express');					// load express module
var bodyParser = require('body-parser');    		// load module for parsing json data
var dataBase = require('mongodb').MongoClient;  	// load MongoDB database module
var Promise = require('promise');               	// load asynchronous returns from functions module
var dataBaseUrl = "mongodb://localhost:27017/db"; 	// dataBase address

var port = 8081;  									// application port
var app = express();						        // create epress configuration object
app.use(bodyParser.json());                         // load bodyParser to app object
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// connect to database function, returns database handler
function Connect() {
    return new Promise(function (fulfill, reject) {
        dataBase.connect(dataBaseUrl, function(err, db) {
            if (err) {
                reject(err);
            }
            fulfill(db);
        });
    });
}

// check if database contains given user
var Authorization=function (login, password) {
    return new Promise(function (fulfill, reject) {
        Connect().done(function (db) {
            db.collection("Users").findOne({ login: login, password: password }, function (err, result) {
                if (err) {
                    reject(err);
                } else {
                    if (result != null) {
                        fulfill(true);
                    }
                    else {
                        fulfill(false);
                    }
                }
                db.close();
            });
        });
    });
}

// check is text format correct
function TextValidation(text, min, max) {
    if (min === undefined) min = 0;
    if (max === undefined) max = Infinity;
    return (text !== undefined) && (/^[a-zA-Z0-9._-]+$/).test(text) && text.length >= min && text.length <= max;
}

// check is user credentials data correct
function UserValidation(body) {
    return new Promise(function(fulfill, reject) {
        if (!TextValidation(body.login, 3, 20) || !TextValidation(body.password, 3, 20)) {
            fulfill(false);
            return;
        }
        Authorization(body.login, body.password).done(function (authentication) {
            fulfill(authentication);
        });
    });
}

//funtion run when server gets post request with url /authorization
app.post('/authorization', function (req, res) {
	UserValidation(req.body).done(function(valid) {
	    if (valid) {
	  	    res.setHeader('Content-Type', "text/html");
			res.statusCode = 200;
			res.end();
	   	}
        else {
            res.setHeader('Content-Type', "text/html");
			res.statusCode = 401; // error has happend
			res.write("Invalid login or password");
			res.end();
		}
    });
});

//start server
var server = app.listen(port, function () {
	MakeLog('Server listening');
});
\end{lstlisting}

\section{Wykorzystane modu³y}

\subsection{Modu³y zewnêtrzne}
Zewnêtrzne modu³y, zainstalowane za pomoc¹ zbioru repozytorium npm, które u¿y³em do realizacji rozwi¹zania to:
\begin{enumerate}
\item express - opisany powy¿ej
\item fs - file stream, odpowiada za obs³ugê zapisu oraz wczytywania plików. 
Wykorzystywany w celu wczytywania plików statycznych aplikacji takich jak index.htm (strona g³ówna w formacie html), main.js (funkcje w jêzyku javaScript), style.css (plik arkuszu stylów, odpowiadaj¹cy za styl prezentacji), favicon (ikona serwisu wyœwietlana w oknie przegl¹darki), czy losowo wybieranych zdjêæ wyœwietlanych w tle serwisu.
\item path - obs³uga ró¿nic miêdzy systemami operacyjnymi. 
Dziêki temu modu³owi mo¿emy zapewniæ ca³kowit¹ sprawnoœæ naszego serwisu niezale¿nie od œrodowiska uruchomieniowego. 
Pozwala niwelowaæ ró¿nice w lokalizacji plików systemowych, czy ³¹cznikach pomiêdzy poszczególnymi folderami przy specyfikacji œcie¿ki do pliku.
\item body-parser - dostarcza mo¿liwoœæ analizowania danych za³¹czonych do odebranego przez serwer ¿¹dania, wykorzystany zosta³ w celu odczytów poszczególnych wartoœci odebranych w formacie json.
\item promise - odpowiada za operowanie wynikami otrzymanymi w wyniku asynchronicznych funkcji. 
Dziêki temu modu³owi nie musimy synchronicznie czekaæ na otrzymanie zwrotu z kolejnych funkcji, natomiast mo¿emy przy u¿yciu wywo³añ zwrotnych zareagowaæ po otrzymaniu okreœlonego wyjœcia.
\item cookie-parser - zapewnia mo¿liwoœæ wykorzystania plików cookie dla specyficznego klienta. 
Dziêki temu modu³owi mo¿emy ustawiaæ, usuwaæ lub edytowaæ wartoœci plików cookie, które zostan¹ przydzielone dla konkretnego u¿ytkownika w ramach ca³ej sesji komunikacji z u¿ytkownikiem lub przez okreœlony przez nas czas. 
\end{enumerate}

\subsection{Modu³y wewnetrzne}
Wewnêtrzne modu³y, czyli takie, które zosta³y napisane przeze mnie specjalnie na u¿ytek projektu, to:
\begin{enumerate}
\item emails.js (wykorzystuj¹cy zewnêtrzny modu³ mongodb) - modu³ zapewnia komunikacjê z baz¹ danych w technologii mongodb, poprzez wywo³ywanie odpowiednich funkcji. 
Zosta³ dostosowany bezpoœrednio do obs³ugi bazy danych dla wykonywanego projektu. 
Dziêki temu plik g³ówny serwera nie musi znaæ budowy, ani wykonywaæ operacji bezpoœrednio na dokumentach bazy danych.
\item db.js (wykorzystuj¹cy zewnêtrzny modu³ nodemailer) - dostarcza obs³ugê wysy³ania wiadomoœci email do u¿ytkowników serwisu w przypadku zajœcia okreœlonych sytuacji, takich jak na przyk³ad otrzymanie nowego zaproszenia czy zmiana statusu zadania. Modu³ dostarcza jedn¹, prost¹ w obs³udze funkcjê zapewniaj¹c¹ obs³ugê wiadomoœci email. 
\end{enumerate}


\chapter{Testy aplikacji}

Po wykonaniu aplikacji zosta³y przeprowadzone testy manualne, sprawdzaj¹ce poprawnoœæ dostarczanej przez serwis funkcjonalnoœci.
Kolejne przypadki testowe:
\newpage 
\section{Uzyskanie dostêpu do statycznych zasobów serwisu}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{11.png}
\captionsetup{labelformat=empty}
\caption[]{U¿ytkownik wysy³a ¿¹danie pod adres serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{12.png}
\captionsetup{labelformat=empty}
\caption[]{U¿ytkownik otrzymuje odpowiedŸ zawieraj¹ca pliki statyczne serwisu (plik html, css, js, zdjêcie w tle i favicon.}
\end{figure}

\newpage 
\section{Rejerstracja w serwisie}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{21.png}
\captionsetup{labelformat=empty}
\caption[]{U¿ytkownik wype³nia formularz rejestracyjny na stronie serwisu i wysy³a dane do serwera. }
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{22.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ otrzymanych danych i w odpowiedzi przesy³a stronê g³ówn¹ aplikacji dostêpn¹ po zalogowaniu na konto lub informacje o b³êdzie.}
\end{figure}

\newpage 
\section{Potwierdzenie adresu email}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{31.png}
\captionsetup{labelformat=empty}
\caption[]{Po podaniu adresu email u¿ytkownik otrzymuje wiadomoœæ email zawieraj¹c¹ link aktywacyjny.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{32.png}
\captionsetup{labelformat=empty}
\caption[]{Po klikniêciu w link. Serwer sprawdza czy otrzymany w linku kod jest prawid³owy dla podanego u¿ytkownika. 
Nastêpnie aktywuje adres email dla odpowiedniego u¿ytkownika, wysy³a w odpowiedzi stronê g³ówn¹ aplikacji oraz wiadomoœæ email o potwierdzeniu.}
\end{figure}

\newpage 
\section{Logowanie siê w serwisie}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{41.png}
\captionsetup{labelformat=empty}
\caption[]{U¿ytkownik wype³nia formularz na stronie serwisu i przesy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{42.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza istnienie konta w serwisie. 
W odpowiedzi u¿ytkownik otrzymuje stronê g³ówn¹ aplikacji lub b³¹d o niepoprawnych danych.
W czasie bycia zalogowanym, co okreœlony czas zostaje wys³ane ¿¹danie aktualizacji danych. 
Aktualizacja nastêpuje równie¿ ka¿dorazowo po otrzymaniu pomyœlnego potwierdzenia wykonania operacji przez serwer.}
\end{figure}

\newpage 
\section{Resetowanie has³a u¿ytkownika}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{51.png}
\captionsetup{labelformat=empty}
\caption[]{Funkcja jest dostêpna po potwierdzeniu adresu email dla konta. 
Po wype³nieniu odpowiedniego formularza na stronie g³ównej serwisu u¿ytkownik wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{52.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza podane dane. W odpowiedzi wysy³a informacje o przetworzeniu ¿¹dania.}
\end{figure}
\newpage 
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{53.png}
\captionsetup{labelformat=empty}
\caption[]{Otrzymujemy tak¿e wiadomoœæ email zawieraj¹c¹ nowe has³o do serwisu.}
\end{figure}

\newpage 
\section{Zmiana danych u¿ytkownika}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{61.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê i wype³nieniu odpowiedniego formularza na stronie serwisu u¿ytkownik wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{62.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Jeœli s¹ poprawne, aktualizuje je.
W przeciwnym wypadku, zwraca komunikat o b³êdzie. 
W odpowiedzi serwer wysy³a stronê g³ówn¹ aplikacji.}
\end{figure}
\newpage 
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{63.png}
\captionsetup{labelformat=empty}
\caption[]{Jeœli zmieni siê równie¿ adres email u¿ytkownik musi go ponownie zweryfikowaæ. }
\end{figure}

\newpage 
\section{Utworzenie nowej tablicy z zadaniami}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{71.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê u¿ytkownik wybiera opcje dodania tablicy, wpisuje wymagane dane i wysy³a je do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{72.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. 
Jeœli s¹ poprawne, serwer tworzy now¹ tablicê dla u¿ytkownika i wysy³a potwierdzenie w odpowiedzi.
W przeciwnym wypadku odpowiada komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Wysy³anie zaproszenia do tablicy}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{01.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê u¿ytkownik wybiera opcje wys³ania zaproszenia do wybranej tablicy, wype³nia dane i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{02.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. 
W odpowiedzi wysy³a potwierdzenie o wys³anym zaproszeniu lub komunikat o b³êdzie.}
\end{figure}

\newpage 
\section{Akceptacja zaproszenia}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{81.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê u¿ytkownik wybiera opcje zaakceptowania oczekuj¹cego zaproszenia i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{82.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Odrzucenie zaproszenia}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{A1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê u¿ytkownik wybiera opcje odrzucenia oczekuj¹cego zaproszenia i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{A2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Wyrzucenie u¿ytkownika z tablicy}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{91.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu siê u¿ytkownik wybiera opcje wyrzucenia u¿ytkownika z okreœlonej tablicy i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{92.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Dodanie zadania}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{A1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu i wybraniu odpowiedniej tablicy u¿ytkownik wybiera opcje dodania zadania, wype³nia dane i przesy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{A2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Dodanie statusu zadania}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{B1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu, wybraniu odpowiedniej tablicy i zadania u¿ytkownik wybiera opcje dodania nowego statusu, uzupe³nia dane i przesy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{B2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Usuwanie zadania}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{C1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu, wybraniu odpowiedniej tablicy i zakoñczonego zadania u¿ytkownik wybiera opcje usuwania zadania i przesy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{C2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Opuszczanie tablicy}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{D1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu u¿ytkownik wybiera opcje opuszczenia tablicy, której jest cz³onkiem i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{D2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}

\newpage 
\section{Usuwanie tablicy}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{E1.png}
\captionsetup{labelformat=empty}
\caption[]{Po zalogowaniu u¿ytkownik wybiera opcje usuniêcia w³asnej tablicy i wysy³a ¿¹danie do serwera.}
\end{figure}
\begin{figure}[!hb]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{E2.png}
\captionsetup{labelformat=empty}
\caption[]{Serwer sprawdza poprawnoœæ danych. Odpowiada potwierdzeniem lub komunikatem o b³êdzie.}
\end{figure}


\chapter{Podsumowanie otrzymanych wyników i wnioski na temat œrodowiska}
Wykonana aplikacja spe³nia zadan¹ w warunkach funkcjonalnoœæ. 
Zosta³y osi¹gniête wszystkie za³o¿enia oraz wymagania aplikacji przy u¿yciu mo¿liwoœci dostarczanej przez technologiê Node.js. 
Stworzony projekt doskonale nadaje siê do u¿ytkowania przez zorganizowane zespo³y do wykonywania okreœlonych zadañ. 
Móg³by byæ na przyk³ad u¿ywany do zarz¹dzania prac¹ zespo³ów deweloperskich pracuj¹cych w ró¿nych metodykach takich jak scrum czy kanban. 
Dostarcza przejrzysty interfejs oraz nieskomplikowan¹ prezentacjê danych dla koñcowych u¿ytkowników, przez co nie wymaga praktycznie ¿adnych szkoleñ lub procesów wdro¿eniowych w celu zdobycia umiejêtnoœci bieg³ej obs³ugi narzêdzia. 
Œrodowisko Node.js wydaje siê byæ bardzo nowoczesnym oraz przysz³oœciowym œrodowiskiem. 
Niew¹tpliwie najwiêkszymi zaletami tej technologii jest ³atwoœæ budowania wymagaj¹cych serwisów internetowych poprzez u¿ycie asynchronicznej obs³ugi wejœcia/wyjœcia, które pozwala na przetwarzanie wielu funkcji w jednym czasie tworz¹c wyj¹tkowo szybkie w dzia³aniu aplikacje. 
Zagadnienie to wymaga jednak umiejêtnoœci w projektowaniu i analizowaniu funkcji programowania asynchronicznego. 
Kod pisany jest w szeroko u¿ywanym jêzyku JavaScript, co zbudowa³o ogromn¹ spo³ecznoœæ zainteresowan¹ technologi¹ Node.js. 
Dziêki temu mo¿emy z ³atwoœci¹ zdobyæ materia³y przydatne w procesie poznawczym œrodowiska. 
Globalne repozytorium npm gwarantuje obs³ugê wielu funkcjonalnoœci, bez potrzeby d³ugiego szukania mo¿liwych rozwi¹zañ. 
Wszystko jest dostêpne bezp³atnie, gotowe do wdro¿enia w tworzonej aplikacji. 
Mimo, ¿e jest to technologia stosunkowo m³oda, obecnie Node.js jest u¿ywany, a co za tym idzie, sprawdzony przez najwiêksze firmy IT w celu obs³ugi ich aplikacji i serwerów. 
Nale¿y byæ œwiadomym wszystkich zalet i wad przy wyborze okreœlonej technologii. 
Node.js nie nadaje siê do ka¿dego typu projektu. 
Nie jest efektywnym œrodowiskiem w korzystaniu z obliczeñ intensywnie wykorzystuj¹cych procesor. 
Jest on jednak¿e idealnym rozwi¹zaniem w przypadku pracy nad wieloma rozwi¹zaniami webowymi. 
Osobiœcie praca w Node.js sprawi³a mi wielk¹ radoœæ i sta³a siê moj¹ ulubion¹ technologi¹ dziêki zapewnionej prostocie i mo¿liwych do uzyskania bez wiêkszego wysi³ku ogromnych mo¿liwoœciach.

\addcontentsline{toc}{chapter}{Bibliografia} 
\begin{thebibliography}{99}
\bibitem{Brown} 
Ethan Brown
\textit{Web Development with Node and Express: Leveraging the JavaScript Stack 1st Edition ISBN: 9781491949306}
\bibitem{Onodi} 
Robert Onodi
\textit{MEAN Blueprints ISBN: 9781783553945}
\bibitem{AngulrJS} 
Pawel Kozlowski, Peter Bacon Darwin
\textit{Mastering Web Application Development with AngularJS ISBN: 9781782161820}
\bibitem{Node.js} 
Dokumentacja jêzyka programowania Node.js. Stan na dzieñ: 2017-07-20
\textit{https://Node.js.org/en/docs}
\bibitem{Node.js wiki}
Artyku³ poœwiêcony technolgii Node.js w serwisie wikipedia. Stan na dzieñ: 2017-07-20
\textit{https://en.wikipedia.org/wiki/Node.js}
\bibitem{libuv}
Dokumentacja biblioteki libuv. Stan na dzieñ: 2017-07-20
\textit{https://github.com/libuv/libuv}
\bibitem{libuv}
Dokumentacja MongoDB. Stan na dzieñ: 2017-07-20
\textit{https://docs.mongodb.com/}

\end{thebibliography}

\addcontentsline{toc}{chapter}{Spis rysunków} 
\listoffigures

\end{document}
